\section{Related Work}

We discuss the closest related works in this Section. We focus on approaches using code similarity to search for known malware apps. There are many other approaches that aim at finding unknown malware.

\textbf{Binary-level function clone detection.} One common approaches is that trace-based approach \cite{DavidY14} captures execution sequences as features for code similarity checking, which can detect the CFG changes. However, this approach does not accurately find the malware codes across different architectures. Static birthmarks \cite{KhooMA13}\cite{AndrewsVSS17} are usually the characteristics in the code that cannot easily be modified such as constant values in field variables, a sequence of method calls, an inheritance structure and used classes. Rendezvous \cite{KhooMA13} first explored the code search in binary code. However, it has two limitations. It relies on ngram features to improve the search accuracy. Secondly, it decomposes the whole CFG of a function into subgraphs. Jannik \cite{FengZXCTY16} \cite{LiuCZLXCS17} propose a system to derive bug signatures for known bugs. They compute semantic hashes for the basic blocks of the binary. When can then use these semantics to find code parts in the binary that behave similarly to the bug signature, effectively revealing code parts that contain the bug. However, it can not be scalable. Deqiang Fu et al. \cite{DFuXYY17} proposed a control flow graph-based malware detection method. They extract features named ``code chunks" from the control flow graph, then use the classification and regression tree (CART) algorithm to classify these features. The method can obtain $96.3\%$ classification accuracy.

\textbf{App clone detection.} Most existing approaches identify malicious apps \cite{EnckGCCJMS14} \cite{JustEM15} typically rely on heavyweight static or dynamic analysis techniques, and cannot detect the unknown malware whose behavior has not been modeled a priori. PiggyApp\cite{ZhouZGJZ13} \cite{0012WLWZHZ015} \cite{DuWL17} \cite{ArpSHGR14} utilize the features (permissions, API, etc.) identified from a major component shared between two apps to find other apps also including this component, then clusters the rest part of these apps' code and samples from individual clusters to manually determine whether the payloads are indeed malicious. In dynamic app cone analysis, applications are executed in a virtual environment. Runtime information is recorded to generate dynamic features for malware detection. For example,  ANDRUBIS \cite{ArpSHGR14}\cite{unknown} dynamically examined the operations for over 1 million apps in four years, which is an off-line analyzer for recovering detailed behavior of individual malicious apps. Enck et al. \cite{DEnckGHTCCJMS14} \cite{EgeleWCB14} \cite{YanY12} proposed TaintDroid, a virtualization-based malware detection method that can trace the flow of sensitive information. In an evaluation of 30 Android applications, TaintDroid found 20 applications had misused users’ private information. However, it has a worse limitation that can not be scalable to handle millions and thousands of apps.

%Yao \cite{DuWL17} present a new malware detection method that automatically divides a function call graph into community structures. The features of these community structures can then be used to detect malware. Arp et al. \cite{ArpSHGR14} proposed a lightweight detection method called DREBIN. This method can extract eight types of static features from Android applications. These features are then input to vector space models for classification by a support vector machine (SVM) algorithm. Their method achieved $94\%$ detection accuracy on $123,453 $ Android applications.

%\textbf{Dynamic app clone detection}
%Another effective approach for malware detection that is resistant to code confusion mechanisms is dynamic analysis. In dynamic app cone analysis, applications are executed in a virtual environment. Runtime information is recorded to generate dynamic features for malware detection. For example,  ANDRUBIS \cite{ArpSHGR14}\cite{unknown} dynamically examined the operations for over 1 million apps in four years, which is an off-line analyzer for recovering detailed behavior of individual malicious apps. Enck et al. \cite{DEnckGHTCCJMS14} proposed TaintDroid, a virtualization-based malware detection method that can trace the flow of sensitive information. In an evaluation of 30 Android applications, TaintDroid found 20 applications had misused users’ private information. However, it has a worse limitation that can not be scalable to handle millions and thousands of apps. Blanket-execution \cite{EgeleWCB14} uses the dynamic run-time environment of the program as features to conduct the code search. This approach can defeat the CFG changes, but it is only evaluated in a single architecture. DroidScope \cite{YanY12} is also a virtualization-based malicious code detection method. It can identify malware by analyzing semantics features of operating system level and Java level. 





