\section{Introduction}
The study of the app homology has recently emerged as a major catalyst for collectively understanding the behavior of complex app in the mobile.  Thousands, and millions of apps have been used around the world from various app markets, such as PP assistant, Android, Google Play, SnapPea and tens of smaller third-party markets. With the rapidly increasing use of apps, code clone, malware code injection bring several serious finance threats. With this prosperity, app homology can be used in the malware detection, plagiarism detection, etc. More than $85\%$ of Android malware rely on app clone to spread to a large number of genuine users \cite{ZhouJ12}, for example, crack paid apps to bypass payment function, modify the advertisement libraries, or even insert various malicious functions, which lead to a serious security problem for the mobile application. Specifically, app developers and security researchers urgently need to find an effective app homology method to satisfy the requirement of fast increasing apps. 
%At the same time, app homology analysis needs to solve the challenge that quickly detect similar functions directly in binaries across multiple platform. 

%As a result, the need for third-party evaluator to accurately and quickly identify benign or malware in mobile app is increasing dramatically.

However, discovering the similar app or derivative app is like distinguishing beans from a mount of jumble beads, even when we are dealing with the known app. To address this critical problem, primitive app researchers statically scans an app for known codes and operations for suspicious activities \cite{DTeuflFFHKO16}. The problem here is that the static approach does not work on new threats. Recent researchers have been actively developing techniques to automatically analyze and detect app homology in the mobile markets. There are several studies that propose the app clone technology and scalable app classification. Detection based on string \cite{Baker95}, detection based on token\cite{IwamotoON12}\cite{YuanG12}, detection based on hash \cite{ChenGZGCZ17}\cite{ZhangLZRS16}, detection based on the program dependence graph \cite{YuLYLYY16} \cite{HamidZ14} and detection based on abstract syntax tree \cite{FuXYY17} \cite{HovemeyerHPS16} \cite{KikuchiGWN15} have shown their scalability to handle thousands and millions of codes. However, some approaches generate too many false negative at handling the classification of malware with imperceptible change, such as sting-based detection, token-based detection. Some approaches are not scalable that can not handle billions of opcodes in multiple app market, such as the program dependence graph. The dynamic method can be circumvented by an app capable of fingerprinting the testing environment \cite{Spreitzenbarth13}, but the dynamic analysis can be heavyweight, which makes it hard to explore all execution paths of an app. 

%The study of data dimensionality reduction has been reported in the literature. Previous approaches include Principal Component Analysis (PCA) \cite{HanWZY18}, Incremental Singular Value Decomposition (SVD) \cite{DGorrell06} \cite{DChenC14} etc. 


There has been several specific challenges:
\begin{enumerate}
  \item There has been an primitive challenge on designing a feasible model to accurately represent scalable apps at the binary codes level. The binary codes of app are very complicated source data. They appear on different markets, and most apps' binary codes are confused. We need extract considerable features to denote binary codes. 
  \item How handle the millions and billions features of app binary codes in multiple markets to accurately analysis the app homology? There is an challenging that we need to accurately find homologous apps in the mass quantity of features of apps. 
  \item There has been facing an challenge to update the feature data for the rapidly increasing apps. Since the update of app feature data needs to relearn all apps' feature including preceding app features in the existing works. However, most existing update approaches are expensive works, and they cost too much additional time and space. We should design a update system that can incrementally and timely update the app feature data. 
\end{enumerate}

%The learning algorithm is widely used in dealing with the classification of big data. 

%Our goal is to address these challenges by proposing a suitable embedding system to transform the binary code of app to a low-dimensional feature vector. Since apps' binary codes are complex, we need to extract more concise and specific storable features represented the apps' binary codes to be easier for the app homology analysis. First, We know that the main content of a app is its smali functions. The control flow graph of the function can greatly preserve the opcode structure. We need to design a embedding approach to preserve both the opcode structure and numeric characteristics of original binary code of the app based on the control flow graph. Second, the embedding features that are extracted from the CFG of app's binary codes are scalable, we need to make the feature dimensionality reduced and compressed. The tensor computations have a great effect on data reduction. We need to propose a tensor embedding model and a compress approach to get more concise and accurate app 's feature data. Third, based on the proposed tensor embedding model, it is easier to propose a incremental update system of the app feature data. Moreover, we also need to prove the monotonicity and validity of the embedding feature theoretically and practically.

Our goal is to address these challenges by proposing a suitable embedding system to transform binary codes of the app to a low-dimensional feature vector.  First, Since apps' binary codes are complex, CFG of the function can greatly preserve the opcode structure. We need to design a embedding approach to preserve both the opcode structure and numeric characteristics of original binary code of the app based on CFG. Second, the embedding features that are extracted from the CFG of app's binary codes are scalable, and tensor computations have a great effect on data reduction. We need to make the feature dimensionality reduced and compressed. Third, based on tensor computations, it is easier to propose an incremental update system of the app features. Moreover, we also need to prove the monotonicity and the validity of embedding features theoretically and practically.
%the 5UD-CFG line embedding and 3TU-CFG tensor embedding make the app homology more scalable than current existing works.based on the extracted control flow graph with the vertex features from the app's binary codes, the two hierarchies model .  Third, the monotonicity of 5UD-CFG line embedding and the injective reversibility of 3TU-CFG tensor model are proved to make sure it more accurate than other works. The 3TU-CFG tensor model also makes the update easy for the search database of the app homology analysis. Evolution shows that finding a unknown function less than $4.6 \times 10^{(-9)}$ seconds in a thousand apps and $0.1$ seconds in $10^8$ apps.

In this paper, our interdisciplinary study focuses on leveraging two hierarchies embedding model to obtain the feature numeric vector based on the CFG of app's binary codes to handle the app homology analysis. The two hierarchies embedding model shows a more effective and accurate app homology strategy than current other works. The main contributions of our work are summarized as follows:
\begin{enumerate}
  \item We develop the first-hierarchy line embedding model for the extracting CFG that each vertex has five eigenvalues by decompiling the app, which is called as 5UD-CFG. Moreover, we can theoretically prove that first-hierarchy embedding feature 5UD-CFG can uniquely represent a CFG.
  \item We design the second-hierarchy 3TU-CFG tensor embedding model based on the extracting first-hierarchy embedding feature 5UD-CFG. Then we propose an special tensor-SVD factorization algorithm to decompose tensor model, which compress 5UD-CFG as 3TU-CFG. This is second-hierarchy embedding process that compresses and clusters the first-hierarchy embedding feature matrixes to greatly accelerate the efficiency of the match and the classification. 
  \item We propose an incremental tensor decomposition algorithm to match the compressing and clustering learning process of tenor embedding model. Compared with the existing work for the update process of the app homology analysis data, the efficiency is greatly improved $2\times$ to $18000\times$.
  \item Our evaluation shows that two hierarchies embedding process obtained feature vector can accelerate the preparation process $4\times$ to $76000\times$ faster than prior works, i.e., Gemini, Genius, Centroid. At the same time, the search and detection time run at least 1 to 2 orders of magnitude faster than prior time even though the prior search time is very minor. Evolution also shows that finding a unknown function less than $4.6 \times 10^{(-9)}$ seconds in a thousand apps and $0.1$ seconds in $10^8$ apps.
\end{enumerate}

%The remainder of the paper is structured as follows. Background of the app clone are given in Section 2. In Section 3, we introduce the  problem definition that we need to solve. In Section 4, we show the overview solution for proposed two-hierarchies embedding model. In Section 5, we propose the first-hierarchy line embedding model,  and prove the monotonicity of the proposed first-hierarchy embedding feature 5UD-CFG. In Section 6, we propose the second-hierarchy tensor embedding model based on the first-hierarchy embedding feature 5UD-CFG. Moreover, we give a learning algorithm to compress and clustering the first-class embedding feature unitary matrix to obtain a more concise embedding feature 3TU-CFG, which can be effective to handle the app homology match and detection. Section 7 illustrates the experiments to verify the efficiency and accuracy of two hierarchies embedding process. We conclude with remarks on future work in Section 8.
                                                                                                                                             